---
title: "ENV Analysis Lab 1"
author: "Hana Esber"
date: "2026-02-10"
output: html_document
---

This is the first lab from this semester that is building on Chapter 1-3 from our textbook and R for Data Science. Most of this lab will be exploratory data analysis looking at two main files: 

1. County_Boundaries.shp: A polygon file containing the boundaries for all counties in the Chesapeake Bay Watershed

2. Non-Tidal_Water_Quality_Monitoring_Stations_in_the_Chesapeake_Bay.shp: point locations of non-tidal monitoring stations in the Chesapeake Bay Watershed.

***** I prefer to have the original lab that Dr. Bitterman created before I answer questions or do my own work. Please skip to "My Tasks" to see the start of this independent work.

### Step 1, load your packages and data
```{r libraries to load, message=TRUE, echo=TRUE}
library(tidyverse)
library(ggplot2) #technically included in tidyverse
library(sf)
```


Next, load your data:
```{r get my data, message=TRUE, echo=TRUE}

## note the ".." as opposed to "." <- need to go back one additional level from where this file is
p.counties <- "./County_Boundaries.shp"
p.stations <- "./Non-Tidal_Water_Quality_Monitoring_Stations_in_the_Chesapeake_Bay.shp"


d.counties <- sf::read_sf(p.counties)
d.stations <- sf::read_sf(p.stations)

glimpse(d.counties)
glimpse(d.stations)

# check for validity geometry
d.stations %>% sf::st_is_valid()
d.counties %>% sf::st_is_valid() # returns false for one feature, so we need to fix

# fix it "in place"
d.counties <- d.counties %>% sf::st_make_valid()

```

In class, we discussed how to use dplyr verbs such as *filter*, *select*, and *mutate*. There are some useful cheatsheets on the RStudio website to help with *dplyr*, *ggplot*, and other functions here: https://posit.co/resources/cheatsheets/

Let's start with the *select* function, which SELECTS attributes that we specify:
```{r selecting stuff, message=TRUE, echo=TRUE}
d.counties %>% dplyr::select(GEOID10, ALAND10) %>% head()
# head truncates the data.frame to the first n rows

```
Note that because we're using a spatial data frame in the `sf` package, the geometry is preserved, even though we didn't specify it. We can also get omit of attributes we DON'T want (but not the geometry attribute) using a `-` flag. For example, the following code "drops" the `NAME10` attribute:

```{r noname, message=TRUE, echo=TRUE}
d.counties %>% dplyr::select(-NAME10) %>% head()

```


We can also specify ranges of attributes that we want to keep (or not):

```{r keeprange, echo=TRUE, message=TRUE}
d.counties %>% dplyr::select(GEOID10:CLASSFP10) %>% head() 

d.counties %>% dplyr::select(-(GEOID10:CLASSFP10)) %>% head() 

d.counties %>% dplyr::select(starts_with("C"))
```


### Grouping data

We can also "group" our data according to categorical data in our data frames. This is useful if you want to create a function that works across the entire group. For example, we'll create a new attribute the calculates the land area of all counties in each state.
```{r grpuex, echo=TRUE, message=TRUE}
d.counties %>% group_by(STATEFP10) %>% mutate(stateLandArea = sum(ALAND10))
```


The above function is useful if you want to make calculations "in place" and use them in further row-by-row functions. However, we can further summarize our data such that we don't see all the extra data not relevant to our query. Note that sometimes buggy geometry can affect normal dplyr functions, so the code below converts the sf data frame to a tibble, then removes the geometry before performing the `group_by` and `summarise` functions. This is an unnecessary step when using validated geometry, but can also speed up computation.

```{r groupSummarise, echo=TRUE, message=TRUE}
d.counties %>% 
  as_tibble() %>% dplyr::select(-geometry) %>% # this line converts the data because of wonky geometry
  group_by(STATEFP10) %>% 
  summarise(stateLandArea = sum(ALAND10))
```
...and we're left with a sum of all the land area in each state (by state FIPS code)


### A diversion into plots

We can also use grouping functions in our visualization. For example:

```{r plots, echo=TRUE, message=TRUE}
d.counties %>%  # . would mean "self" in this case
  ggplot(., aes(x = as.factor(STATEFP10), y = ALAND10)) +
  geom_boxplot(aes(fill = STATEFP10))
```
Or:

```{r plots2, echo=TRUE, message=TRUE}
d.counties %>% 
  ggplot(., aes(x = ALAND10)) +
  geom_histogram(aes(fill = STATEFP10)) +
  labs(title = "not the most useful plot, but you get the idea")
```


### Spatial operations

Since we have spatial data, we can perform some basic spatial operations with it. First, let's take a look at the coordinate reference system (CRS) for each file:

```{r crs, echo=TRUE, message=TRUE}
d.counties %>% sf::st_crs()
d.stations %>% sf::st_crs()
```

They're the same, but we can formally check
```{r crscomp, echo=TRUE, message=TRUE}
d.counties %>% sf::st_crs() == d.stations %>% sf::st_crs()
```

We need to make sure the files have the same CRS before we do our spatial operations using the both of them. But to make the problem more tractable, let's first pare down our data such that we only have the counties in the state of Delaware:

```{r mysubset, echo=TRUE, message=TRUE}
del.counties <- d.counties %>% dplyr::filter(STATEFP10 == 10)
```

then, we can perform a *spatial intersection* to find all of the monitoring stations within our Delaware subset

```{r intersect, echo=TRUE, message=TRUE}
del.stations <- sf::st_intersection(d.stations, del.counties)
```

Plotting this small number of points will be ok, so let's look at the data first, then check the plot:
```{r mypoints, echo=TRUE, message=TRUE}
glimpse(del.stations)
plot(del.stations)
```
There are only 2 points, and the plot isn't super helpful without any other sort of spatial reference, but you've successfully completed your first spatial operation in R!


`sf` has a number of other useful functions built-in that you can try. For example, a quick calculation of the area of each county in Delaware:
```{r areacalc, echo=TRUE, message=TRUE}
del.counties %>% st_area() 
```

Note that `sf` gives you the units of the calculation, but also that the output data are in the form of a vector


## My Tasks ##

This lab requires you to put together many of the tasks demonstrated above, in class, help documentation (don't forget the `?` command!), and in your readings. I don't expect you'll know them all immediately, so you'll need to reference those resources, your classmates, and possibly web resources as well. This process is representative of real-world problem solving in this domain. There are a very large number of packages and functions available to you in R, and no one person knows how to use them all. So be inventive, be clever, and be persistent!

Complete each task COMPLETELY USING R CODE. YOU MUST SHOW YOUR WORK FOR EACH ANSWER. Label your variables sensibly and use comments such that I can find your answers and your work.

### Task 1: Basic data manipulation

1.1 For each county, calculate its land area as percentage of the total area (land + water) for that state.
```{r}
#creating a new df that has the sum of land,water, and their sum together
new.d.counties <- d.counties %>%
group_by(STATEFP10) %>%
  mutate(totalStateArea = sum(AWATER10 + ALAND10)) %>%
      ungroup() %>%
      group_by(COUNTYFP10) %>%
  mutate(countyLandPerc = (ALAND10 / totalStateArea) * 100)


```


1.2 For each state, find the county that has the largest proportion of its land as water (water area / total area)
```{r}
#create column for county water area/ county total area
new.d.counties <- new.d.counties %>%
group_by(STATEFP10) %>%
  mutate(countyWaterPercent = (AWATER10 / totalStateArea) *100) 

# search for which county has the highest percent of water area
new.d.counties %>%
group_by(STATEFP10) %>% dplyr::slice_max(countyWaterPercent)
```


1.3 Count the number of counties in each state
```{r}
new.d.counties  %>%
as_tibble() %>% dplyr::select(-geometry) %>% #have to say as tibble to minus geometry
  group_by(STATEFP10) %>%
  summarise(count= n(), .groups="drop") 

```


1.4 Which station has the shortest name (`STATION_NA`) in the study area?
```{r}
#loading in the stringr package to deal with character strings
library(stringr)

#calculate the length of each name
d.stations <- d.stations %>%
  mutate(name_length = str_length(STATION_NA))

d.stations %>% dplyr::slice_min(name_length)

```


### Task 2: Plotting attribute data
...for each plot, label your axes properly and give your plot a title

2.1 Make a scatterplot showing the relationship between land area and water area for each county. Color each point using the state variable
```{r}
task2.1_plot <- new.d.counties %>%
  group_by(COUNTYFP10) %>%
  ggplot(aes(x=ALAND10, y=AWATER10)) +
    geom_point(aes(color=STATEFP10)) +
  labs(x="County Land Area (m2)",
       y="County Water Area (m2)",
       title="Relationship between county land and water area",
       subtitle="In the Chesapeake Bay Watershed") +
  theme_bw()

task2.1_plot
  
```


2.2 Make a histogram of drainage area (`Drainage_A`) for all monitoring stations
```{r}
task2.2_plot <- d.stations %>% 
  ggplot(., aes(x = Drainage_A)) +
  geom_histogram(fill="purple") +
  labs(title = "Drainage Area of all monitoring stations within the CBW",
       x="Drainage Area",
       y="Frequency")

task2.2_plot
```


2.3 Make a similar histogram of drainage area (`Drainage_A`) for all monitoring stations. This time, shade/color each portion of the histogram's bar(s) using the state variable
```{r}
#intersection of new.counties.d and d.stations to find the state
station_location <- sf::st_intersection(d.stations, new.d.counties)

task2.3_plot <- station_location %>% 
  ggplot(., aes(x = Drainage_A)) +
  geom_histogram(aes(fill=STATEFP10)) +
  labs(title = "Drainage Area of all monitoring stations within the CBW",
       x="Drainage Area",
       y="Frequency",
       fill="State FP Code")

task2.3_plot
```


### Task 3: Write a function
3.1 Write a function that does the following:

A. accepts a vector of arbitrary numbers, calculates the mean, median, maximum, and minimum of the vector

B. Sorts the vector

C. returns a list of those values from A and the sorted vector from B

D. the function should only work with numeric values and print an error message if any other data type are found

Test it with the following vectors
```{r}
fun <- function(a) {
  
  #check if vector is numeric, if not, print error
  if (!is.numeric(a)) {
    stop("Error: This not a numeric vector.")
  }    
  #calculate listed statistics
  mean_value <- mean(a)
  median_value <- median(a)
  max_value <- max(a)
  min_value <- min(a)
  
  #store statistics in a vector
  stats <- c(mean_value,median_value,max_value,min_value)
  
  #sort vector by smallest to largest values
  stats_sorted <- sort(stats, decreasing = FALSE)
  
  #print both a and the calculated values that are sorted
  print(a)
  print(stats_sorted)
  
}

#testing function
test.1 <- c(1, 0, -1)
test.2 <- c(10, 1000, 100)
test.3 <- c(.1, .001, 1e8)
test.4 <- c("a", "b", "c")

fun(test.1)
fun(test.2)
fun(test.3)
#uncomment to check
#fun(test.4)

```


### Task 4: A (slightly) more complex spatial analysis. 
...Note, you may need to find supplementary data to help you with these tasks

4.1 Calculate the number of monitoring stations in each state
```{r}
#count monitoring stations by state
station_location  %>%
as_tibble() %>% dplyr::select(-geometry) %>% #have to say as tibble to minus geometry
  group_by(STATEFP10) %>%
  summarise(count= n(), .groups="drop") 
```


4.2 Calculate the average size of counties in New York (that are also in this study area)
```{r}
#create NY counties
ny.counties <- d.counties %>% dplyr::filter(STATEFP10 == 36)

#finding total size
ny.counties <- ny.counties %>%
  group_by(COUNTYFP10)  %>%
  mutate(totalcountyArea = sum(AWATER10 + ALAND10)) 

#find mean size of the counties
mean(ny.counties$totalcountyArea)

```


4.3 Calculate which state has monitoring stations with the greatest average drainage area (Drainage_A)
```{r}
station_location <- station_location %>%
  group_by(STATEFP10) %>%
  mutate(avg_drainage = mean(Drainage_A)) 

#search for what state has the greatest avg drainage area
station_location %>%
  group_by(STATEFP10) %>%
dplyr::slice_max(avg_drainage)
```



## Questions

1. In using the intersection functions, are the following two statements equivalent? If not, explain how. Be sure to think about BOTH the spatial data structures AND the attribute data. Would your answer be different if we were using different types of data?

```{r}
sf::st_intersection(d.stations, del.counties)
sf::st_intersection(del.counties, d.stations)
```
I think the differences is what type of data will be retained. In the first scenario, station data will be preserved and it will find what Delaware counties have a station. In the second scenario, it preserves del.counties data and it is useful to see if there are stations in those counties. I think 


2. What did you find challenging in this lab? What was new?


3. What types of activities would you like to see in labs this semester?